# 自动监听机制说明

## 概述

插件采用**双重监听机制**来确保能够及时捕获文档筛选条件的变化：

1. **事件监听（Event-based）** - 主要方式
2. **轮询检查（Polling）** - 备用方案

## 实现原理

### 方式一：事件监听（主要方式）

```typescript
bitable.base.onSelectionChange(() => {
  getFilterInfo()
})
```

#### 工作原理

1. **订阅事件**：使用飞书 Bitable API 的 `onSelectionChange` 方法订阅视图选择变化事件
2. **触发时机**：
   - 用户切换视图时
   - 用户修改筛选条件时
   - 视图状态发生变化时
3. **回调执行**：当事件触发时，自动调用 `getFilterInfo()` 获取最新的筛选条件

#### 优点
- ✅ **实时响应**：事件触发后立即获取，延迟极低
- ✅ **性能好**：只在变化时执行，不占用额外资源
- ✅ **用户体验佳**：变化立即反映在界面上

#### 缺点
- ⚠️ **依赖 API**：需要飞书 API 支持该事件
- ⚠️ **可能遗漏**：如果 API 不支持某些变化类型，可能无法捕获

### 方式二：轮询检查（备用方案）

```typescript
setInterval(() => {
  getFilterInfo()
}, 3000) // 每 3 秒检查一次
```

#### 工作原理

1. **定时执行**：使用 `setInterval` 每隔固定时间（3秒）执行一次
2. **主动检查**：无论是否有事件触发，都会主动获取筛选条件
3. **状态对比**：通过对比前后状态，检测是否有变化

#### 优点
- ✅ **可靠性高**：不依赖事件，总能获取最新状态
- ✅ **兜底保障**：即使事件监听失败，也能正常工作
- ✅ **兼容性好**：适用于所有场景

#### 缺点
- ⚠️ **有延迟**：最多延迟 3 秒才能检测到变化
- ⚠️ **资源消耗**：定期执行，会消耗一定的 CPU 和网络资源

## 代码实现位置

核心代码在 `components/FilterMonitor.tsx` 的 `useEffect` 钩子中：

```75:111:components/FilterMonitor.tsx
  /**
   * 自动监听筛选条件变化的实现
   * 
   * 采用双重监听机制确保及时捕获筛选条件变化：
   * 
   * 1. 事件监听（Event-based）- 主要方式
   *    - 使用 bitable.base.onSelectionChange() 监听视图选择变化
   *    - 当用户切换视图或修改筛选条件时，会触发此事件
   *    - 优点：实时响应，性能好
   *    - 缺点：依赖飞书 API 的事件支持
   * 
   * 2. 轮询检查（Polling）- 备用方案
   *    - 使用 setInterval 每 3 秒检查一次筛选条件
   *    - 作为事件监听的补充，确保不会遗漏变化
   *    - 优点：可靠性高，不依赖事件
   *    - 缺点：有延迟，消耗一定资源
   */
  useEffect(() => {
    // 组件挂载时立即获取一次筛选条件
    getFilterInfo()

    // 检查是否在飞书环境中
    if (typeof window === 'undefined' || !(window as any).bitable) {
      return
    }

    const bitable = (window as any).bitable
    
    // ========== 方式一：事件监听（主要方式） ==========
    let unsubscribe: (() => void) | undefined
    
    try {
      // 监听视图选择变化事件
      // 当用户切换视图、修改筛选条件时，会触发此回调
      if (bitable.base && typeof bitable.base.onSelectionChange === 'function') {
        unsubscribe = bitable.base.onSelectionChange(() => {
          console.log('📊 检测到视图选择变化，重新获取筛选条件')
          getFilterInfo()
        })
        console.log('✅ 已成功订阅视图变化事件')
      } else {
        console.warn('⚠️ onSelectionChange API 不可用')
      }
    } catch (err) {
      console.warn('⚠️ 无法订阅视图变化事件:', err)
    }

    // ========== 方式二：轮询检查（备用方案） ==========
    // 定期检查筛选条件，确保不会遗漏任何变化
    // 即使事件监听失败，也能通过轮询获取最新状态
    const POLLING_INTERVAL = 3000 // 每 3 秒检查一次
    
    const interval = setInterval(() => {
      // 静默检查，不显示加载状态（避免频繁闪烁）
      getFilterInfo()
    }, POLLING_INTERVAL)
    
    console.log(`🔄 已启动轮询检查，间隔: ${POLLING_INTERVAL}ms`)

    // 清理函数：组件卸载时取消监听和轮询
    return () => {
      console.log('🧹 清理监听器和轮询')
      clearInterval(interval)
      if (unsubscribe && typeof unsubscribe === 'function') {
        unsubscribe()
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])
```

## 执行流程

```
组件挂载
    ↓
立即获取一次筛选条件（getFilterInfo）
    ↓
尝试订阅事件监听（onSelectionChange）
    ├─ 成功 → 事件触发时自动获取
    └─ 失败 → 仅依赖轮询
    ↓
启动轮询检查（每 3 秒）
    ↓
用户操作（修改筛选条件）
    ├─ 事件监听触发 → 立即获取（实时）
    └─ 轮询检查 → 最多 3 秒后获取（兜底）
    ↓
更新界面显示
```

## 优化建议

### 1. 调整轮询间隔

可以根据实际需求调整轮询间隔：

```typescript
// 更频繁的检查（更及时，但消耗更多资源）
const POLLING_INTERVAL = 1000 // 1 秒

// 更少的检查（节省资源，但延迟更大）
const POLLING_INTERVAL = 5000 // 5 秒
```

### 2. 智能轮询

可以根据是否有事件监听来调整轮询频率：

```typescript
// 如果有事件监听，可以降低轮询频率
const POLLING_INTERVAL = unsubscribe ? 5000 : 2000
```

### 3. 防抖处理

如果担心频繁调用，可以添加防抖：

```typescript
let lastFilterInfo: string | null = null

const checkFilterChange = async () => {
  const currentInfo = JSON.stringify(await getFilterInfo())
  if (currentInfo !== lastFilterInfo) {
    lastFilterInfo = currentInfo
    // 更新界面
  }
}
```

## 调试方法

### 查看控制台日志

打开浏览器开发者工具，可以看到以下日志：

- `✅ 已成功订阅视图变化事件` - 事件监听成功
- `📊 检测到视图选择变化，重新获取筛选条件` - 事件触发
- `🔄 已启动轮询检查，间隔: 3000ms` - 轮询启动
- `🧹 清理监听器和轮询` - 组件卸载

### 测试监听是否工作

1. 打开插件界面
2. 在文档中修改筛选条件
3. 观察插件界面是否自动更新
4. 查看控制台是否有相关日志

## 常见问题

### Q: 为什么需要两种方式？

A: 双重保障机制确保在各种情况下都能正常工作：
- 如果事件监听可用，优先使用（实时响应）
- 如果事件监听不可用或失败，轮询作为备用（确保功能正常）

### Q: 轮询间隔可以调整吗？

A: 可以，在代码中修改 `POLLING_INTERVAL` 常量即可。建议范围：1-5 秒。

### Q: 轮询会消耗很多资源吗？

A: 每 3 秒执行一次 API 调用，资源消耗很小。如果担心，可以：
- 增加轮询间隔
- 只在事件监听失败时启用轮询
- 添加智能检测，只在必要时轮询

### Q: 如何知道事件监听是否成功？

A: 查看浏览器控制台：
- 看到 `✅ 已成功订阅视图变化事件` 表示成功
- 看到 `⚠️ onSelectionChange API 不可用` 表示失败

